Description: Reject X11 forwardings after 20 min session duration
Author: Damien Miller <djm@mindrot.org>
Abstract:
 This patch is a backport of [1] to openSSH 5.5p1 as found in Debian
 squeeze and fixes CVE-2015-5352.
 .
 Whereas the original patch [1] builds around the config option
 ForwardX11Timeout, this patch rejects X11 forwarding requests
 once a hard-coded 20mins-timeout (1200secs) has been reached.
 .
 This 20mins-timeout in openSSH 5.5 stems from the fact that openSSH
 creates Xauth cookies with a default (hard-coded in openSSH 5.5)
 expiration timeout of 1200secs. In later openSSH version, this 1200secs
 value can be configured via the above named config option
 ForwardX11Timeout.
 .
 [1] https://anongit.mindrot.org/openssh.git/commit/?h=V_6_9&id=1bf477d3cdf1a864646d59820878783d42357a1d 
 .
 Backport to openSSH 5.5p1 by Mike Gabriel <mike.gabriel@das-netzwerkteam.de>

--- a/channels.c
+++ b/channels.c
@@ -148,6 +148,9 @@
 static char *x11_saved_data = NULL;
 static u_int x11_saved_data_len = 0;
 
+/* Deadline after which all X11 connections are refused */
+static u_int x11_refuse_time;
+
 /*
  * Fake X11 authentication data.  This is what the server will be sending us;
  * we should replace any occurrences of this by the real data.
@@ -884,6 +887,13 @@
 	u_char *ucp;
 	u_int proto_len, data_len;
 
+	/* Is this being called after the refusal deadline? */
+	if (x11_refuse_time != 0 && (u_int)time(NULL) >= x11_refuse_time) {
+		verbose("Rejected X11 connection which expired after "
+		        "20mins of session duration");
+		return -1;
+	}
+
 	/* Check if the fixed size part of the packet is in buffer. */
 	if (buffer_len(b) < 12)
 		return 0;
@@ -1439,6 +1449,12 @@
 		error("setsockopt SO_REUSEADDR fd %d: %s", fd, strerror(errno));
 }
 
+void
+channel_set_x11_refuse_time(u_int refuse_time)
+{
+	x11_refuse_time = refuse_time;
+}
+
 /*
  * This socket is listening for connections to a forwarded TCP/IP port.
  */
--- a/clientloop.c
+++ b/clientloop.c
@@ -164,6 +164,7 @@
 static int connection_out;	/* Connection to server (output). */
 static int need_rekeying;	/* Set to non-zero if rekeying is requested. */
 static int session_closed = 0;	/* In SSH2: login session closed. */
+static u_int x11_refuse_time;	/* If >0, refuse x11 opens after this time. */
 
 static void client_init_dispatch(void);
 int	session_ident = -1;
@@ -256,6 +257,7 @@
 }
 
 #define SSH_X11_PROTO "MIT-MAGIC-COOKIE-1"
+#define X11_TIMEOUT_SLACK 60
 void
 client_x11_get_proto(const char *display, const char *xauth_path,
     u_int trusted, char **_proto, char **_data)
@@ -268,6 +270,12 @@
 	int got_data = 0, generated = 0, do_unlink = 0, i;
 	char *xauthdir, *xauthfile;
 	struct stat st;
+	u_int now, x11_timeout_real;
+
+	/* Hard-coded prior to openSSH 6.0, in later versions, the
+	 * timeout value gets passed in as function parameter.
+	 */
+	u_int timeout = 1200;
 
 	xauthdir = xauthfile = NULL;
 	*_proto = proto;
@@ -297,15 +305,34 @@
 			xauthdir = xmalloc(MAXPATHLEN);
 			xauthfile = xmalloc(MAXPATHLEN);
 			strlcpy(xauthdir, "/tmp/ssh-XXXXXXXXXX", MAXPATHLEN);
+			/*
+			 * The authentication cookie should briefly outlive
+			 * ssh's willingness to forward X11 connections to
+			 * avoid nasty fail-open behaviour in the X server.
+			 */
+			if (timeout >= UINT_MAX - X11_TIMEOUT_SLACK)
+				x11_timeout_real = UINT_MAX;
+			else
+				x11_timeout_real = timeout + X11_TIMEOUT_SLACK;
 			if (mkdtemp(xauthdir) != NULL) {
 				do_unlink = 1;
 				snprintf(xauthfile, MAXPATHLEN, "%s/xauthfile",
 				    xauthdir);
 				snprintf(cmd, sizeof(cmd),
 				    "%s -f %s generate %s " SSH_X11_PROTO
-				    " untrusted timeout 1200 2>" _PATH_DEVNULL,
-				    xauth_path, xauthfile, display);
+				    " untrusted timeout %u 2>" _PATH_DEVNULL,
+				    xauth_path, xauthfile, display,
+				    x11_timeout_real);
 				debug2("x11_get_proto: %s", cmd);
+				if (x11_refuse_time == 0) {
+					now = time(NULL) + 1;
+					if (UINT_MAX - timeout < now)
+						x11_refuse_time = UINT_MAX;
+					else
+						x11_refuse_time = now + timeout;
+					channel_set_x11_refuse_time(
+					    x11_refuse_time);
+				}
 				if (system(cmd) == 0)
 					generated = 1;
 			}
@@ -1706,6 +1733,12 @@
 		    "malicious server.");
 		return NULL;
 	}
+	if (x11_refuse_time != 0 && (u_int)time(NULL) >= x11_refuse_time) {
+		verbose("Rejected X11 connection which expired after "
+		        "20mins of session duration");
+		return NULL;
+	}
+
 	originator = packet_get_string(NULL);
 	if (datafellows & SSH_BUG_X11FWD) {
 		debug2("buggy server: x11 request w/o originator_port");
--- a/channels.h
+++ b/channels.h
@@ -265,6 +265,7 @@
 
 /* x11 forwarding */
 
+void	 channel_set_x11_refuse_time(u_int);
 int	 x11_connect_display(void);
 int	 x11_create_display_inet(int, int, int, u_int *, int **);
 void     x11_input_open(int, u_int32_t, void *);
